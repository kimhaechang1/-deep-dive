## 11. 원시값과 객체의 비교

자바스크립트에서 제공하는 7가지 데이터타입은 크게 원시타입과 객체타입으로 구분 할 수 있다.

원시 타입의 값, 즉 원시 값은 변경 불가능한 값이다. 

그에비해 객체 타입의 값, 즉 객체는 변경가능한 값이다.

원시 값을 변수에 할당하면 변수에는 실제 값이 저장된다.

이에비해 객체 타입의 값, 즉 객체를 변수에 할당하면 변수에는 참조 값이 저장된다.

> ### 11.1. 원시값 
>
> > ### 11.1.1. 변경 불가능한 값
> > 
> > 원시타입의 값, 즉 원시값은 변경 불가능한 값이다.
> >
> > 다시말해, 한번 생성된 원시 값은 읽기 전용 값으로서 변경 할 수 없다.
> > 
> > 중요한건 변경 불가능한 것은 변수가 아니라 값이라는 점이다.
> >
> > 변수는 언제든지 재할당을 통해 변수 값을 변경(엄밀히 말하면 교체)할 수 있다.
> >
> > 변수의 상대개념인 상수는 재할당이 금지된 변수를 말한다.
> > 
> > 상수도 값을 저장하기 위한 메모리 공간이 필요하므로 변수라고 할 수 있다.
> > 
> > 하지만 변수는 언제든지 재할당을 통해 변수 값을 변경할 수 있지만
> >
> > 상수는 단 한 번만 할당이 허용되므로 변수 값을 변경 할 수 없다.
> > 
> > 따라서 상수와 변경 불가능한 값을 동일시 하는 것은 안된다. 
> >
> > 상수는 재할당이 금지된 변수 일 뿐이다.
> > 
> > ```javascript
> > const o = {};
> > // const 키워드를 사용해 선언한 변수는 재할당이 금지된다. 상수는 재할당이 금지된 변수일 뿐이다.
> > // const 키워드를 사용해 선언한 변수에 할당한 원시 값은 변경 할 수 없다.
> > // 하지만 const 키워드를 사용해 선언한 변수에 할당한 객체는 변경 할 수 있다.
> > o.a = 1;
> > console.log(o) // -> { a : 1 }
> > ```
> > 즉, 원시 값을 할당한 변수에 새로운 원시 값을 재 할당하면 
> >
> > 메모리 공간에 저장되어 있는 재할당 이전의 원시값을 변경하는 것이 아니라 
> > 
> > 새로운 메모리 공간을 확보하고 재할당한 원시 값을 저장한 후, 
> > 
> > 변수는 새롭게 재할당된 원시 값을 가리킨다. 이 때 변수가 참조하던 메모리 공간의 주소가 바뀐다
> > 
>
> <br>
> 
> > ### 11.1.2. 문자열과 불변성
> >
> > 원시 값을 저장하려면 먼저 확보해야하는 메모리 공간의 크기를 결정해야 한다.
> >
> > 이를 위해 원시 타입별로 메모리 공간의 크기가 미리 정해져 있다고 했다.
> >
> > 단, ECMAScript 사양에 문자열 타입과 숫자 타입 이외의 원시 타입은 
> >
> > 그 크기를 명확히 규정하지 않아서 브라우저 제조사의 구현에 따라 다를 수 있다.
> >
> > ```javascript
> > // 유사배열
> > // 유사배열 객체란 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고, length 프로퍼티를 갖는 객체를 말한다.
> > var str = 'string';
> > console.log(str[0]) // -> 's'
> > // 원시 값인 문자열이 객체처럼 작동한다.
> > console.log(str.length) // -> 6
> > // 문자열은 유사배열이므로 배열과 유사하게 인덱스를 통해 각 문자에 접근할 수 있다
> > // 하지만 문자열은 원시 값이므로 변경 할 수 없다.
> > str[0] = 'S';
> > console.log(str) // -> 'string'
> > ```
>
> <br>
>
> > ### 11.1.3. 값에 의한 전달
> >
> > 변수에 원시 값을 갖는 변수를 할당하면
> >
> > 할당 받는 변수에 할당되는 변수의 원시값이 복사되어 전달된다.
> >
> > 이를 값에 의한 전달이라고 한다.
> >
> > 이렇게 되면 두 변수 모두 같은 값을 갖고 있지만, 서로다른 메모리 공간에 저장된 별개의 값이다.
> >
> > ```javascript
> > var score = 80;
> > var copy = score // 메모리공간에 score와 같은 크기의 메모리를 할당하고 같은 숫자타입의 값을 할당하고 해당 주소를 copy변수가 가지고 있다.
> > 
> > console.log(score === copy) // -> true
> > 
> > score = 100; 
> > // score 와 copy는 서로다른 메모리가 확보되어 있는 상황이므로
> > // 서로 같은 숫자 타입의 값이어도 별개의 값으로 취급한다.
> > // 따라서 scroe에 할당된 값을 100으로 재할당하더라도 copy의 값에는 영향이 없다.
> > 
> > console.log(score === copy) // -> false
> > ```
> > 여기서 오해하면 안되는 부분은
> > 
> > 값을 직접적으로 전달하는것이 아닌 메모리 주소를 전달한다고 생각해야 한다.
> > 
> > 왜냐하면 변수에는 값이 직접적으로 들어있는것이 아닌, 메모리주소가 들어있기 때문이다.
> > 
> > 사실은 ECMAScript 사양에는 변수를 통해 메모리를 어떻게 관리해야 하는지를 명확하게 정의되어 있지 않다.
> >
> > 어떤 식으로 동작하던지 간에
> >
> > 결국은 두 변수의 원시 값은 서로 다른 메모리 공간에 저장된 별개의 값이 되어
> > 
> > 한쪽에서 재할당을 통해 값을 변경하더라도 다른 한 쪽에 영향을 주지 않는다는점이 중요하다.
>
> <br>
>
> 식별자란 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다.
>
> 식별자는 주로 변수가 선언되었을 때 변수명으로서 쓰일 수 있으며
>
> 일반적으로 변수가 선언되고 값이 할당되었을 때 
>
> 자바스크립트는 식별자를 통해서 메모리에 어떤 주소에 값이 들어가 있는지를 구분한다.
>
> ### 11.2. 객체
>
> 객체는 프로퍼티의 개수가 정해져 있지 않으며,
>
> 동적으로 추가되고 삭제 할 수 있다.
>
> 또한 프로퍼티의 값에도 제약이 없다.
>
> 따라서 객체는 원시 값과 같이 확보해야 할 메모리 공간의 크기를 사전에 정해둘 수 없다.
>
> > ### 11.2.1 변경 가능한 값
> >
> > 객체 타입의 값, 즉 객체는 변경 가능한 값이다.
> > 
> > 원시 값을 할당한 변수는 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 원시 값에 접근 할 수 있다.
> > 
> > 하지만 객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 참조 값에 접근 할 수 있다.
> > 
> > 참조 값은 생성된 객체가 저장된 메모리 공간의 주소, 그 자체다.
> > 
> > 객체를 할당한 변수의 경우 "변수는 객체를 참조하고 있다" 라고 표현한다.
> >
> > 원시 값은 변경 불가능한 값이므로 재할당 외에는 값을 변경하는 방법이 없다.
> > 
> > 하지만 객체를 할당한 변수는 재할당 없이 동적으로 프로퍼티를 추가 할 수 있고
> > 
> > 프로퍼티 값을 갱신할 수 있으며, 제거할 수도 있다.
> >
> > 즉, 객체는 변경가능한 값이므로 메모리에 저장된 객체를 직접 수정할 수 있다.
> > 
> > 이러한 객체는 프로퍼티의 값의 크기부터 시작해 모든 것이 일정하지 않으므로
> > 
> >  생성하고 관리하는 방식이 매우 복잡하며 비용이 많이드는 일이다.
> > 
> > 따라서 메모리를 효율적으로 사용하기 위해, 객체를 복사해 생성하는 비용을 절약하여 성능을 향상시키기 위해
> > 
> > 객체는 변경 가능한 값으로 설계되어 있다.
> > 
> > 이러한 변경 가능한 값이기 때문에 구조적 단점이 있다.
> > 
> > 그것은 **여러 개의 식별자가 하나의 객체를 공유** 할 수 있다는 것이다.
> > 
> > ```javascript
> > // 얕은 복사와 깊은 복사
> > // 얕은 복사와 깊은 복사로 생성된 객체는 원본과는 다른 객체이다.
> > // 하지만 얕은 복사는 객체에 중첩되어 있는 객체의 경우 참조값만 복사하지만
> > // 깊은 복사는 모두 복사한다.
> > const o = { x : { y : 1 } };
> > // 얕은 복사
> > const c1 = { ...o };
> > console.log(c1 === o); // false
> > console.log(c1.x === o.x) // true
> > ```
> 
> <br>
> 
> > ### 11.2.2 참조에 의한 전달
> >
> > 객체를 가리키는 변수를 다른 변수에 할당하면 
> > 
> > 원본의 참조 값이 복사되어 전달된다.
> > 
> > 따라서 두 변수는 다른 메모리 공간에 주소를 참조하고 있지만
> > 
> > 그 두 공간속 값은 참조이며 같은 메모리 주소를 참조 하고 있다.
> > 
> > 따라서 원본 또는 사본 중 어느 한쪽에서 객체를 변경 하면 서로 영향을 주고 받는다.
> >
> > 결국 "값에 의한 전달"과 "참조에 의한 전달"은 
> > 
> > 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해서 전달하는 면에서 동일하다.
> > 
> > 따라서 자바스크립트에서는 "참조에 의한 전달"은 존재하지 않는다.
> >
