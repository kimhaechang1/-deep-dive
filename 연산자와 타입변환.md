# 모던 자바스크립트 deep-dive

모던 자바스크립트 deep-dive를 읽으며

몰랐던 부분에 대해 기술한다. 

다음에 다시보면 이해할 수 있도록!

___


## 7. 연산자

> ### 7.1. 산술 연산자
>
> 산술연산자는 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만든다.
>
> 산술 연산이 불가능한 경우, NaN을 반환한다.
>
> 연산자에서 부수효과란 피연산자의 값을 변경하는 것을 말한다.
> 
> > #### 7.1.2. 단항 산술연산자
> >
> > 1개의 피연산자를 산술연산하여 숫자 값을 만든다.
> >
> > |단항 산술 연산자|의미|부수효과|
> > |---|---|---|
> > |++|증가|O|
> > |--|감소|O|
> > |+|어떠한 효과도 없다. 음수를 양수로 변환하지도 않는다.|X|
> > |-|양수를 음수로, 음수를 양수로 반전한 값을 반환한다.|X|
> >
> > 단항 산술연산자에서 ```++```와 ```--```는 **부수효과**가 있다는 점을 주의해야 한다.
> >
> >```javascript
> >// ++, -- 연산자는 피연산자의 값을 변경하는 암묵적 할당이 이루어진다.
> > var x = 1;
> > x++; // x = x + 1;
> > console.log(x) // 2
> > x--; // x = x - 1
> > console.log(x) // 1 
> >```
> > 숫자 타입이 아닌 피연산자에 ```+``` 단항 연산자를 사용하면
> > 
> > 피연산자를 숫자 타입으로 변환하여 반환한다.
> >
> > 이때 피연산자를 변경하는 것이 아니고, 숫자 타입으로 변환한 값을 생성해서 반환한다.
> > 
> > 따라서 부수효과는 없다.
> > 
> >```javascript
> >// ++, -- 연산자는 피연산자의 값을 변경하는 암묵적 할당이 이루어진다.
> > var x = '1';
> > console.log(+x) // 문자열을 숫자타입으로 변경
> > console.log(x) // '1'으로서 피 연산자의 값을 변경시키지는 못한다.
> > x = true;
> > console.log(+x) // 1 로서 불리언 타입을 숫자 타입으로 변경
> > x = false;
> > console.log(+x) // 0 로서 불리언 타입을 숫자 타입으로 변경
> > x = 'hello';
> > console.log(+x) // NaN 로서 숫자타입으로 변경 불가능함을 나타냄
> > 1 + true // -> 2 가 된다. 왜냐하면 true를 암묵적으로 1로 변환하여 연산하기 때문
> > 1 + null // -> 1 이 된다. 왜냐하면 null은 숫자타입으로 변경될 시 0으로 변환되기 때문
> > 1 + undefined // -> NaN이 된다. 왜냐하면 undefined는 숫자타입으로 변경 불가능하기 때문
> >```
> > 위의 예제에서 볼 수 있듯이 개발자의 의도완 다르게 
> > 
> > 자바스크립트 엔진에서 암묵적으로 타입이 자동 변환 되기도 한다.
> > 
> > 이러한 변환을 **암묵적 타입변환** 또는 **타입 강제변환** 이라고 한다.
>
> ### 7.3. 비교 연산자
>
> 비교 연산자는 좌항과 우항의 피 연산자를 비교한 다음
>
> 그 결과를 부릴언 값으로 반환한다.
>
> 비교 연산자는 if문이나 for문과 같은 제어문의 조건식에서 주로 사용한다.
> 
> > #### 7.3.1. 동등/일치 비교 연산자
> >
> > 1개의 피연산자를 산술연산하여 숫자 값을 만든다.
> >
> > |비교 연산자|의미|부수효과|
> > |---|---|---|
> > |==|동등비교로서 두 피연산자의 값이 같음|X|
> > |===|일치비교로서 두 피연산자의 타입과 값이 같음|X|
> > |!=|부동등비교로서 두 피연산자의 값이 다름|X|
> > |!==|불일치 비교로서 두 피연산자의 타입과 값이 다름|X|
> >
> > 동등 비교 연산자는 좌항과 우항의 피연산자를 비교할 때 
> >
> > 먼저 **암묵적 타입 변환**을 통해 **타입을 일치**시킨 후 같은 값인지 비교한다.
> >
> >```javascript
> >// 동등비교
> > 5 == 5; // -> true
> > 5 == '5'; // -> true 
> >```
> > 위와 같은 동등비교 연산자는 결과를 예측하기 어렵고 실수하기 쉽다.
> > 
> > 따라서 동등비교 연산자보다는 일치비교 연산자를 사용하는 것이 좋다.
> >
> > 일치비교 연산자는 좌항과 우항이 타입도 같고 값도 같은 경우에 한하여 true를 반환한다.
> > 
> > 이러한 일치비교 연산자에서도 ```NaN```의 경우는 주의해야 한다.
> >
> > 왜냐하면 ```NaN```은 유일하게 자기 자신과도 일치하지 않기 때문이다.
> >
> > 따라서 ```NaN```인지 검사하고 싶은 경우 빌트인 함수 ```Number.isNaN```을 사용한다.
> > 
> > 추가적으로 ```0```의 경우 자바스크립트에서는 ```음의 0```과 ```양의 0```으로 나누어져 있지만
> > 이 둘을 동등비교를 하던 일치비교를 하던 ```true```를 반환하게 된다.
> >
> > 따라서 정확하게 검사하고 싶다면 ```Object.is()```메서드를 사용하여 검사한다.
> >```javascript
> > // 일치비교
> > 5 === 5 // -> true
> > 5 === '5' // -> false
> > NaN === NaN // -> false
> > Number.isNaN(NaN) // -> true
> > Number.isNaN(1+undefined) // -> true
> > 0 == -0 // -> true
> > 0 === -0 // -> true
> > Object.is(0, -0) // -> false
> > Object.is(NaN, NaN) // -> true
> >```
>
> ### 7.5. 논리연산자
>
> 논리연산자는 우항과 좌항의 피연산자를 논리연산한다.
>
> 비교 연산자는 if문이나 for문과 같은 제어문의 조건식에서 주로 사용한다.
> 
> 논리 부정 연산자는 언제나 불리언 값을 반환한다.
>
> 그래서 피연산자가 반드시 **불리언 값** 일 필요는 없다.
> 
> 만약에 불리언값이 아니게 되면 암묵적 타입변환으로 인해 불리언 타입으로 변환된다.
>
> ```javascript
>  !0; // -> true : 0은 타입변환 시 false에 해당하고 그것의 NOT이므로 true가 반환된다.
>  !'hello' // -> false : 문자열이 비어있지 않으므로 true인데 NOT이므로 false가 반환된다.
> ```
>  

<br>

## 9. 타입변환

> ### 9.1. 타입변환이란?
>
> 개발자가 의도적으로 값의 타입을 변환하는것을 명시적 타입변환 또는 타입캐스팅이라 한다.
>
> 하지만 의도치 않게 변하는 것을 암묵적 타입변환 또는 타입 강제변환 이라고 한다.
>
> 이러한 명시적 타입변환이나 암묵적 타입변환은 **기존의 원시값을 직접 변경하지는 않는다.**
>
>```javascript
> var x = 10;
> var str = x + '';
> console.log(typeof str, str); // string '10'
> console.log(typeof x, x); // number 10
>```
> 위의 경우에서 자바스크립트 엔진은 표현식 ```x+''```를 평가하기 위해 
>
> ```x``` 변수의 숫자값을 바탕으로 새로운 문자열 값 ```'10'```을 생성하고 
>
> 이것으로 표현식 ```'10'+''```를 평가한다.
>
> 이 때 새로 생성된 문자열 ```'10'```은 ```x```변수에 재할당 되지 않는다.
> 
> 즉, 암묵적 타입 변환은 기존의 변수 값을 재할당하여 변환하는 것이 아니다.
>
> 자바스크립트 엔진은 표현식을 에러없이 평가하기 위해 
>
> 피연산자의 값을 암묵적으로 타입을 변환시켜서 새로운 값을 만들고 
>
> 연산을 수행 한 후 버린다.
>
> ### 9.2. 암묵적 타입변환
>
> 자바스크립트 엔진은 표현식을 평가할 때 개발자의 의도와는 상관없이
>
> 코드의 문맥을 고려해 암묵적으로 데이터 타입을 강제 변환 할 때가 있다.
>
> ```javascript
> // 피연산자가 모두 문자열 타입이어야 하는 문맥
> '10' + 2 // -> '102'
> // 피연산자가 모두 숫자 타입이어야 하는 문맥
> 5 * '10' // -> 50
> ```
> 위와 같은 상황에서 변수명 value는 자바스크립트의 실행 컨텍스트에 등록되게 된다.
>
> ### 9.3. 명시적 타입 변환
>
> 표준 빌트인 생성자 함수(```String```, ```Number```, ```Boolean```)를 ```new ``` 연산자 없이 호출하는 방법,
> 
> 빌트인 메서드를 사용하는 방법, 그리고 암묵적 타입 변환을 이용하는 방법이 있다.
>
> 그 결과를 불리언 값으로 반환한다.
> 
> > #### 9.3.1. 문자열 타입으로 변환
> >
> > 1. String 생성자 함수를 new 연산자 없이 호출하는 방법
> > 
> > 2. ```Object.prototype.toString```메서드를 사용하는 방법
> > 
> > 3. 문자열 연결 연산자를 사용하는 방법
> >
> >```javascript
> > // 1. String 생성자 함수를 new 연산자 없이 호출하는 방법
> > String(NaN) // -> "NaN"
> > String(Infinity) // -> "Infinity"
> > 
> > // 2. Object.prototype.toString 메서드 사용
> > (NaN).toString() // -> "NaN"
> > (Infinity).toString() // -> "Infinity"
> >
> > // 3. 문자열 연결 연산자 사용
> > NaN + '' // -> "NaN"
> > Infinity + '' // -> "Infinity"
> >```
> > #### 9.3.1. 숫자 타입으로 변환
> >
> > 1. Number 생성자 함수를 new 연산자 없이 호출하는 방법
> > 
> > 2. ```parseInt```, ```parseFloat``` 메서드를 사용하는 방법
> > 
> > 3. 단항 연산자 ```+``` 를 이용하는 방법
> >
> > 4. 산술 연산자 ```*``` 를 이용하는 방법
> >
> >```javascript
> > // 1. Number 생성자 함수를 new 연산자 없이 호출하는 방법
> > Number('0') // -> 0
> > Number('10.2') // -> 10.2
> > Number(true) // 1
> > Number(false) // 0
> > 
> > // 2. parseInt, parseFloat 메서드를 사용하는 방법
> > // 단, 문자열 -> 숫자 타입만 가능하다.
> > parseInt('0') // 0
> > parseFloat('10.2') // 10.2
> >
> > // 3. 단항 연산자 + 사용
> > +'10.2' // -> 10.2
> > +true // -> 1
> > +false // -> 0
> > 
> > // 4. 산술 연산자 * 사용
> > 1 * '10' // -> 10
> > 1 * true // -> 1
> >```
> > #### 9.3.1. 불리언 타입으로 변환
> >
> > 1. Boolean 생성자 함수를 new 연산자 없이 호출하는 방법
> > 
> > 2. 부정논리 연산자를 두 번 사용하는 방법
> > 
> >```javascript
> > // 1. Boolean 생성자 함수를 new 연산자 없이 호출하는 방법
> > Boolean('0') // -> true
> > Boolean('') // -> false
> > Boolean(0) // -> true
> > Boolean(1) // -> false
> > Boolean({}) // -> true : 객체 타입을 불리언 타입으로
> > Boolean([]) // -> true : 객체 타입을 불리언 타입으로
> >
> > // 2. 부정논리 연산자를 두 번 사용하는 방법
> > !!'0' // -> true
> > !!'' // -> false
> > !!0 // -> false
> > !!1 // -> true
> > !!{} // -> true
> > !![] // -> true
> >
> >```
> ### 9.4. 단축 평가
> 
> > #### 9.4.1. 논리연산자를 사용한 단축평가
> >
> > 논리 합 연산자 또는 논리 곱 연산자 표현식의 평가 결과는 불리언 값이 아닐 수 도 있다.
> >
> > 논리 합 연산자 또는 논리 곱 연산자 표현식은 언제나 2개의 피연산자 중 어느 한쪽으로 평가된다는 점이다.
> >
> > ```javascript
> > 'Cat' && 'Dog' // -> 'Dog'
> > ```
> > 위의 상황에서 현재 표현식에 논리 곱 연산자를 사용하였고 
> > 
> > 왼쪽의 피 연산자 값이 true이지만 **오른쪽 피연산자의 값에 따라 평가 값이 나뉘므로 'Dog'를 반환한다.**
> > 
> > 논리 합 연산자의 경우에도 동일하게 작동한다.
> >
> > ```javascript
> > 'Cat' || 'Dog' // -> 'Cat'
> > ```
> > 
> > 논리 합 연산자의 경우에는 평가식에서 연산자 기준 왼쪽 피연산자의 값이 true이냐 false냐에따라 값이 결정되므로
> >
> > 여기서 왼쪽 피연산자의 값을 반환하게 된다.
> >
> > 따라서 단축평가란 **논리 연산의 결과값을 결정짓는 피연산자의 타입을 변환하지 않고 반환하는것을 의미**한다.
> > 
> > 이와같이 단축평가는 표현식을 평가하는 도중에 평가 결과가 확정 된 경우 나머지 평과 과정을 생략한다.
> > 
> > 이러한 단축평가를 사용하게 된다면 if문을 대체 할 수 있게 된다.
> > ```javascript
> > // done값이 true일 경우 특정 값을 message에 할당
> > var done = true;
> > var message = '';
> > 
> > // if 문 사용시
> > if(done) message = '완료';
> > 
> > // 단축 평가 사용시
> > message = done && '완료'; // 오른쪽 피연산자의 결과에 따라 표현식의 값이 할당됨, 따라서 '완료' 할당
> > 
> > // done값이 false일 경우 특정 값을 message에 할당
> > var done = false;
> > var message = '';
> > 
> > // if 문 사용시
> > if(!done) message = '미완료';
> > 
> > // 단축 평가 사용시
> > message = done || '미완료'; // 오른쪽 피연산자의 결과에 따라 표현식의 값이 할당됨, 따라서 '미완료' 할당
> > ```
> > **객체를 가리키기를 기대하는 변수가 null 또는 undefined가 아닌지 확인하고 프로퍼티를 참조할 때**
> > 
> > 객체는 키와 값으로 구성된 프로퍼티의 집합이다.
> > 
> > 만약 객체를 가리키기를 기대하는 변수의 값이 객체가 아니라 
> > 
> > null 또는 undefined인 경우 객체의 프로퍼티를 참조하면 에러가 발생한다.
> >
> > 이 때 단축평가를 사용하면 에러를 발생시키지 않는다.
> > 
> > ```javascript
> > var elem = null;
> > var value = elem.value; // Error 발생
> > 
> > // 단축평가
> > var value = elem && elem.value // elem 이 null 이면 elem.value를 확인하지 않고서 null 반환이 가능해짐
> > ```
> > **함수의 매게변수에 기본값을 설정 할 때**
> > 
> > 함수를 호출 할 때 인수를 전달하지 않으면 매게변수에는 ```undefined```가 할당된다.
> > 
> > 이 때 단축평가를 사용해 매게변수의 기본값을 설정하면 된다.
> >  
> > ```javascript
> > function getString(str){ 
> >     str = str || '';
> >     return str.length;
> > }
> > getString() // -> 0
> > getString('hi') // -> 2
> > 
> > // ES6 매게변수 기본값 설정
> > function getString(str = ''){ 
> >     return str.length;
> > }
> > getString() // -> 0
> > getString('hi') // -> 2
> > ```
> >
> > #### 9.4.2. 옵셔널 체이닝
> >
> > ES11에 도입된 옵셔널 체이닝 연산자 ```?.``` 는 
> >
> > 좌항에 피연산자의 값이 ```null``` 또는 ```undefine```인 경우 ```undefined```을 반환하고 
> > 
> > 그 밖의 값인 경우 참조를 이어간다.
> > 
> > 단축평가는 ```Falsy```냐 ```Truthy```냐 이지만 
> >
> > 옵셔널 체이닝에서는 ```null```또는 ```undefined```이냐를 잘 구분해야 한다.
> > 
> > ```javascript
> > var elem = null;
> > var value = elem.value; // Error 발생
> > 
> > // 단축평가
> > var value = elem && elem.value; // elem 이 null 이면 elem.value를 확인하지 않고서 null 반환이 가능해짐
> > 
> > // ES11 옵셔널 체이닝
> > var value = elem?.value; // -> undefined : elem이 null이므로 undefined 반환
> > 
> > // null 또는 undefined가 아니면 참조한다는 점에서 주의!
> > var str = '';
> > var length = str?.length // -> 0 : str이 Falsy한 값이지만 null 또는 undefined가 아니므로 0 반환
> > ```
> > #### 9.4.3. null 병합 연산자
> >
> > ES11에 도입된 null병합 연산자 ```??```는 
> > 
> > 좌항의 피연산자가 null 또는 undefined인 경우 우항의 피연산자를 반환하고
> >
> > 그렇지 않으면 좌항의 피연산자를 반환한다.
> > 
> > 이러한 null병합 연산자 ```??```는 변수에 기본값을 설정할 때 유용하다.
> > 
> > 주의 할 점은 위의 옵셔널 체이닝과 마찬가지로 Truthy 와 Falsy한 값이 아닌
> > 
> > ```null```또는 ```undefined```값에 따라 반환값이 달라지는점이다.
> > 
> > ```javascript
> > var str = null ?? 'default string'; 
> > // -> 'default string' : null병합 연산자 기준 좌측 피연산자가 null또는 undefined 이므로
> > ```

