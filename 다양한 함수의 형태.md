## 12. 함수

> ### 12.7. 다양한 함수의 형태
>
> > ### 12.7.1. 즉시 실행 함수
> > 
> > 함수 정의와 동시에 즉시 호출되는 함수를 즉시 실행 함수(IIFE : Immediately Invoked 
Function Expression)라고 한다.
> > 
> > **즉시실행 함수는 단 한번만 호출되며 다시 호출할 수 없다**.
> >
> > ```javascript
> > // 익명 즉시실행 함수
> > (function (){
> >     var a = 3;
> >     var b = 5;
> >     return a * b;   
> > }());
> > ``` 
> >
> > 즉시 실행 함수는 함수 이름이 없는 익명 함수를 사용하는 것이 일반적이다.
> > 
> > 중요한 점은 그룹 연산자 내에 기명 함수는 함수 선언문이 아니라 함수 리터럴로 평가되며
> >
> > 함수 이름은 함수 몸체에서만 참조할 수 있는 식별자 이기 때문에
> > 
> > 즉시 실행 함수를 다시 호출 할 수는 없다.
> > 
> > 아래의 예제들은 즉시 실행 함수를 정의하다가 생기는 오류들이다.
> > ```javascript
> > // 함수 선언문처럼 보이나 함수 이름이 없으므로 에러가 발생한다.
> > function () {
> >        
> > }();
> > 
> > // 함수 선언문 처럼 보이면 값으로 평가될수 없는 표현식이므로 중괄호 바로뒤에 세미콜론이 붙게 된다.
> > // 또한 분리되어 떨어진 소괄호묶음은 그룹 내 연산자로 판별되고
> > // 이로인해 피 연산자가 없으므로 에러가 발생한다.
> > function foo () {
> >        
> > }();
> > ```
> > 
> > 따라서 익명함수를 써도되고 기명함수를 써도되지만
> >
> > 값으로 평가될 수 있는 표현식이어야 한다.
> > 
> > 즉 함수 객체를 생성할 수 있다면 그룹내 연산자가 아니더라도 사용해도 좋다.
> >
> > 즉시 실행 함수도 일반 함수처럼 값을 반환할 수 있고, 인수를 전달 할 수 있다.
> >
> > ```javascript
> > var res = (function (){
> >     var a = 3;
> >     var b = 5;
> >     return a * b;   
> > }());
> > console.log(res) // -> 15
> >
> > res = (function (a,b){
> >     return a * b;   
> > }(3,5));
> >
> > console.log(res) // -> 15
> > ```
> >
> 
> <br>
> 
> > ### 12.7.3. 중첩 함수
> > 
> > 함수 내부에 정의된 함수를 중첩함수(nested function) 또는 내부 함수(inner Function)라 한다.
> > 
> > 그리고 중첩 함수를 포함하는 함수는 외부 함수(outer function)라 부른다.
> > 
> > 일반적으로 중첩 함수는 자신을 포함하는 외부 함수를 돕는 헬퍼 함수의 역할을 한다.
> > ```javascript
> > function outer(){
> >     var x = 1;
> >     // 중첩 함수
> >     function inner(){
> >         var y = 2;
> >         // 외부 함수의 변수를 참조 할 수 있다.
> >         console.log(x + y);
> >     }
> >     inner();    
> > }
> > outer();
> > ```
> > 
> > ES6부터 함수 정의는 문이 위치할 수 있는 문맥이라면 어디든지 가능하다.
> > 
> > 단, 호이스팅으로 인해 혼란이 발생 할 수 있으므로 if문이나 for문 등의 코드블록에서
> > 
> > 함수 선언문을 통해 함수를 정의하는 것은 바람직하지 않다.
> 
> <br>
>
> > ### 12.7.4. 콜백 함수
> >
> > ```javascript
> > function repeat1(n){
> >     for(var i = 0;i<n;i++) console.log(i);
> > }
> > repeat1(5); // -> 0 1 2 3 4
> > function repeat2(n){
> >     for(var i = 0;i<n;i++){
> >         if(i % 2) console.log(i);
> >     } 
> > }
> > repeat2(5); // -> 1 3
> > ```
> >
> > 위의 두 함수에서 공통적인 부분은 for 문을 통해 반복해주는 부분이다.
> >
> > 단지 홀수를 출력하느냐, 모든 수를 출력하느냐의 차이에 따라 함수의 개수를 늘려가는건 좋지 않은 방식이다.
> > 
> > 위의 예제에서 드러난 문제를 해결하기 위해서는
> > 
> > 공통적인 부분은 하나의 함수로 처리하고, 로직에 따라 달라지는 부분을
> > 
> > 추상화하여 함수 외부에서 내부로 전달하는 방식이 좋다.
> > 
> > 이럴 때 필요한 것이 콜백함수이다.
> > 
> > 콜백함수는 특정함수의 매개변수로 넘어온 함수를 의미한다.
> > 
> > ```javascript
> > function repeat(n, f){
> >     for(var i = 0;i<n;i++){
> >         f(i);
> >     }    
> > }
> > var logAll = function (n){
> >     console.log(i);
> > }
> > repeat(5, logAll); // -> 0 1 2 3 4
> > var logOdd = function (n){
> >     if(i % 2) console.log(i);
> > }
> > repeat(5, logOdd); // -> 1 3
> > ```
> >
> > 공통적인 부분인 "for 문을 통한 반복"은 그대로 두고
> > 
> > 경우에 따라서 변경되는 로직은 ```f``` 로 추상화 하여
> > 
> > 서로다른 로직이 담긴 함수를 매개변수로 전달받아서 
> >
> > 반복문 내부에서 호출되도록 처리하였다.
> >
> > 이로인해 ```repeat``` 함수는 더이상 내부 로직에 강력하게 신경 쓸 필요 없고
> >
> > 로직은 어짜피 매개변수로 넘어온 함수가 담당하므로 유연한 구조가 형성된다.
> > 
> > 이렇게 매개변수로 넘어온 함수를 **콜백함수**라 하며, 
> > 
> > 매개변수를 통해 함수의 외부에서 콜백함수를 전달받은 함수를 **고차함수**라고 한다.
> >
> > 고차함수는 매개변수로 넘어온 콜백함수의 호출시점을 원하는대로 결정할 수 있다.
> > 
> > 만약 콜백함수가 고차 함수 내부에만 호출된다면 
> > 
> > 콜백함수를 익명 함수로 정의하면서 곧바로 고차함수의 매개변수로 전달하는것이 일반적이다.
> > 
> > ```javascript
> > repeat(5, function(i){
> >     if(i % 2) console.log(i);
> > })
> > ```
> > 
> > 이 때 콜백함수로 전달된 함수 리터럴은 고차 함수가 호출 될때 마다 평가되어 함수객체를 생성한다.
> > 
> > 따라서 콜백함수를 다른 곳에서도 호출 할 필요가 있다거나
> > 
> > 콜백 함수를 전달 받는 함수가 자주 호출 될 필요가 있다면
> > 
> > 함수 외부에서 콜백함수를 정의 한 후 함수 참조를 고차함수에 전달하는 편이 효율적이다.
>
> <br>
> 
> > ### 12.7.5 순수 함수와 비순수 함수
> > 
> >  - 순수 함수 : 어떤 외부 상태에 의존하지도 않고 변경하지도 않는, 즉 부수효과가 없는 함수
> >  - 비 순수 함수 : 순수함수의 반대
> > 
> > 순수 함수는 어떤 외부상태에도 의존하지 않고 오직 **매개변수**를 통해 함수 내부를 전달된 **인수에게만 의존**해 값을 생성해 반환한다.
> > 
> > 외부상태 : 전역변수, 서버 데이터, 파일, Console, DOM 등
> > 
> > 만약 외부 상태에 의존하지 않더라도 내부 상태가 호출할 때 마다 변화하는 값(예 : 현재 시간)이면 순수함수가 아니다.
> >
> > ```javascript
> > var count = 0;
> > 
> > function pure_increase(n){
> >     return ++n; // 매개변수에 의존
> > }
> > console.log(count); // -> 0 
> > 
> > function impure_increase(){
> >     return ++count; // 외부상태의 값에 의존
> > }
> > console.log(count) // -> 1
> > ```
> > 위의 예제에서 ```pure_increase``` 함수는 함수 외부의 값에 의존하는것이 아닌
> > 
> > 매개변수를 통해 넘어온 인수에 의존하여 값을 생성하므로 순수함수가 된다.
> > 
> > 하지만 ```impure_increase```함수는 함수 외부의 값에 의존하여 상태를 변경하므로 비순수함수가 된다.
> > 
> > 이러한 비순수함수가 많아지게 되면 함수형 프로그래밍을 지키기 어렵게 된다.
> > 
> > 함수형 프로그래밍은 순수함수와 보조 함수의 조화를 통해 외부 상태를 변경하는 부수효과를
> >
> > 최소화 해서 불변성을 지향하는 프로그래밍 패러다임이다.
> > 
> > 로직 내에 존재하는 조건문과 반복문을 제거해서 복잡성을 해결하며
> > 
> > 변수 사용을 억제하거나 생명주기를 최소화해서 상태 변경을 피해 오류를 최소화 하는것을 목표로 한다.
> > 
> > 자바스크립트는 멀티 패러다임 언어이므로 객체지향 프로그래밍 뿐만 아니라
> > 
> > 함수형 프로그래밍 또한 적극적으로 활용하고 있다.
